# java 高效编程的最佳实践
## 1. 使用静态工厂方法代替构造器
### 静态工厂的惯用名称
1. from --- 类型转换方法，它只有单个参数，返回该类型的一个相对实例
```java
Date d = Date.from(instant);
```
2. of ---聚合方法，带有多个参数，返回该类型的一个实例，把他们合并起来
```java
Set<Rank> faceCards = EnumSet.of(JACK,QUEEN, KING);
```
3. valueOf --- 比 from 和 of 更加繁琐 的一种代替方法
```java
BigInteger primer = BigInteger.valueOf(Integer.MAX_VALUE);
```
4. instance 或者 getInstance --- 返回的实例是通过 方法的（如有）参数来描述的，但是不能说与参数有同样的值。
```java
StackWalker luke = StackWalker.getInstance(optins);
```
5 .  create 或 newInstance ---像 instance 或者 getInstance 一样，但 create 或 newInstance 能确保每次都返回一个新的实例
```java
Object newArray = Array.newInstance(classObj, arrayLen);
```
6. getType --- 像 getInstance 一样，但是在工厂方法处于不同的类中的时候使用，type 表示工厂方法返回的对象类型。
```java
FileStores fileStore = Files.getFileStore(path);
```
7. newType --- 像newInstance 一样，但是在工厂方法处于不同类的时候使用，type 表示工厂方法返回的对象类型。
```java
BufferedReader br = Files.newBufferedReader(path);
```
8. type ---getType 和 newType 的简版
```java
List<Complaint> litany = Collections.list(legacyLitany);
```


## 2. 遇到多个构造器参数时需要考虑 使用  构建器

## 3. 用私有的构造器或者枚举类型强化Singleton 熟悉
### 创建单例的三种方式：
1. 共有静态成员

## 4. 通过私有的构造器强化不可实例化的能力


## 5. 优先考虑使用依赖注入来引入资源

不要用Singleton 和静态工具类来实现依赖一个或者多个底层的资源类，且该资源的行为会影响到该类的行为。也不要用该类来创建这些资源。

而应该将这些资源或者工厂传递给构造器，通过他们来创建类。 这样就极大的提升了类的灵活性、可重用性、可测试性。

## 6. 避免创建不必要的对象
1. 优先使用基本类型而不是装箱的基本类型

## 7. 消除过期的对象引用
1. 只要是自己管理的内存，就应该警惕内存泄露问题 

数组中所有的对象引用都同等有效

2. 缓存中的数据也容易引起内存泄露

使用 WeakHashMap ： 只要 在缓存之外存在 对某个键的引用，该项就有意义，当缓存项过期后，就删除

3. 监听器 和其他回调

弱引用

## 8. 避免使用终结方法和清除方法

## 9. try-with-resources 优先于 try -  finally

# 对于所有对象都通用的方法

## 10. 覆盖 equals 方法时，请遵循通用约定
1. 自反性（reflexive）： 对于任意非 null 的引用值 x， x.equals(x) 必须 返回 true;
2. 对称性（symmetirc）： 对于任何 非 null的引用值 x和 y，当且仅当 x.equals(y) 等于 true时，y.equals(x) 也等于 true；
3. 传递性（transitive）： 对于任何 非 null的引用值 x,y和 z,当且仅当 x.equals(y) 等于 true时，y.equals(z) 也等于 true,那么x.equals(z) 也等于 true；
4. 一致性（consistent）： 对于任意非null 的引用 x和y，只要 equals 比较操作在对象中没有被修改，多次调用 equals 方法返回值一致。
5. 对于任何非 null 类型 的引用x, x.equals(null) 必须返回false；

不要轻易覆盖 equals方法。

### 最佳诀窍：
1. 使用 == 操作符检查 “对象是否是这个对象的引用”。如果是 则返回true。
2. 使用 instanceof 操作符检查 “参数为正确的类型”， 如果不是， 则返回false。
3. 把参数转换为正确的数据类型。 因为在转换之前 进行了 instanceof 判断，因此确保回成功
4. 对于该类中的每个关键域（significant），检查参数中的域是否与对象中的 域相匹配、

### 注意事项
1. 覆盖equals 方法 必须要覆盖 hashCode 方法
2. 不要企图让 equals 方法过于智能
3. 不要将equals 申明中的Object 对象替换成其他类型。

## 11. 覆盖 equals 方法时总要覆盖 hashCode 方法
覆盖 equals 方法，必须覆盖hashCode方法。负责程序将无法正确运行。hashCode 方法必须遵循Object 约定的通用约定，不同的对象必须拥有不同的 hashCode、

## 12. 始终要覆盖 toString()
要在 编写的每个可实例化的类中覆盖 Object 的同String方法，除非超类已经做了。 toString 方法应该美观的格式返回一个关于对象的简介的有效的描述

## 13. 谨慎的覆盖 clone 方法

1. clone 方法 就是另一个构造器，必须确保 他不会伤害到原始的对象，并确保正确的创建被克隆对象中的约束条件。
2. final域禁止使用 clone 方法的
3. 实现了 Cloneable 接口的类都应该覆盖clone 方法， 并且时共有的方法，他返回的类型时他本身。
    1. 该方法 先调用 super.clone() 方法。
    2. 然后修正任何需要修正的域。
## 14. 考虑实现 comparable 接口

1. 类中 实现 Comparable 接口，重新 compareTo 方法
2. Comparator 接口中使用 比较器 构造方法。

# 类和接口
## 15. 使类和成员的可访问性最小化

应该始终 尽可能合理的降低程序元素的可访问性。 在设计了一个 最小的共有 api 后，应该防止把任何散乱的类，接口或者成员变成 api 的一部分。

## 16. 要在共有类中使用访问方法而非共有域
共有类永远不应该暴露可变的域。

## 17. 使得可变性最小化
为了使得类比可变，可以采取一下5条：
1. 不要提供任何回修改对象状态的方法。
2. 保证类不会被扩展
3. 申明所有的 域 都是final 的
4. 申明所有的与都是 私有的。
5. 确保对于认可可变组件的互斥访问。

## 18. 符合优先于 继承
继承打破了封装性。 子类可以使用 父类的一些细节。

## 19. 要么设计继承并提供说明，要么禁止继承、
**好的 API文档应该描述一个给定的方法做了什么工作，而不是描述它如何做到。**

## 20. 接口由于抽象类
接口通常是定义允许多个实现的类型的最佳途径。 

## 21. 为后代设计接口

## 22. 接口 只用于定义类型
接口应该被用来定义类型，而不应该被用来导出常量

## 23. 类层次优先于标签类

## 24. 静态成员类优于非静态成员类

### 套嵌类
- 静态成员类： static member class

（内部类）
- 非静态成员类： nonstatic member class
- 匿名类: anonymous class
- 局部类：local class

在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修饰过的 this 构造或者外围实例的引用。
如果 套嵌类的实例可以在在他外围类的实例之外独立 存在，则这个套嵌类必须是静态内部类。

## 25. 限制源文件为单个顶级类
永远不要把多个顶级类或者接口放到一个源文件中。

# 泛型
## 26. 不要使用原生态类型

## 27. 消除非受检查的警告

非受检查异常很重要，不要忽略他们。

## 28. 列表优先与数组
1. 数组是协变的（covariant）。提供了运行时的类型安全，但是没有提供编译时的类型安全。
2. 不能创建泛型数组，泛型是不可具体化的（non-reifiable）类型

## 29. 优先考虑泛型

## 30. 优先考虑泛型方法

## 31. 利用有限的统配符来提升 api 的灵活性
 规则： PECS : producer - extends ， consumer-super

comparable 和 comparator 都是消费者

## 32. 谨慎并用 泛型 和可变参数
可变参数和泛型不能良好的合作，因为可变参数设施是构建在顶级数组之上的一个技术露底。泛型数组有不同的类型规则。虽然泛型可变参数不是类型安全的，但他们是合法的。如果选择
编写带有泛型的可变参数的方法，首先确保该方法是类型安全的。

## 33. 优先考虑类型安全的异构容器

集合 API 说明了泛型的一般用法，限制每个容器只能有固定数目的类型参数。可以通过将类型参数放在键上而不是容器上来避开这一限制。

# 枚举 和 注解
一种类： 枚举类型（enum type）
一种接口： 注解类型（annotation type）

## 34. 用 enum 代替 int 常量

## 35. 用实例域代替序数

## 36. 用 EnumSet 代替位域

## 37. 用 EnumMap 代替序数索引

## 38. 用接口模拟可扩展的枚举
虽然无法编写可扩展的枚举类型，却可以编写接口以及实现接口的基础枚举类型来对他进行模拟。

## 39. 注解优先与命名模式

## 40. 坚持使用 Override 注解
使用 Override注解来申明超类或者超接口，编译器就可以帮助我们防止大量的错误。

## 41. 用标记接口 定义类型
标记接口： 不包含方法申明的接口。它只指明了一个类实现了具有某种属性的接口。
# lambda 和 stream
java 8 增加特性
- 函数接口：functional interface
- Lambda
- stream

## 42. lambda 优先于匿名类

## 43. 方法引用优先于lambda

## 44. 坚持使用标准的接口函数

## 45. 谨慎的使用 Stream

## 46. 优先选择使用 stream 中无副作用的函数

## 47. stream 优先使用collection 作为返回类型

## 48. 谨慎使用 stream并行
在 stream 上通过 并行获得 的性能，最好是通过 ArrayList，HashMap，HashSet 和 ConcurrentHashMap实例，数组，int 范围，long 范围等。
这些数据的共性是：都可以被精确、轻松的分成任意大小的子范围。

尽量不要用并性 Strean pipeline。

# 方法

## 49. 坚持 参数的有效性

## 50. 必要是进行保护性拷贝

## 51. 谨慎设计方法签名

## 52. 慎用重载

## 53. 慎用可变参数

## 54. 返回 0 长度的数组或者集合，而不是 null

## 55. 谨慎返回 optional

## 56. 为所有 导出 的 api 元素编写文档注释

## 57. 将局部变量的作用域最小化

## 58. for - each 循环优先于 传统的 for 循环 

## 59. 了解和使用类库
- Java.lang
- java.util
- java.io

不要重复咋轮子。

## 60. 如果需要精确值，避免使用 float 和 double
- BigDecimal

## 61. 基本类型优先于装箱基本类型

## 62. 如果其他类型更适合，则避免使用 字符串

## 63. 了解字符串链接的性能
不要使用字符串 链接符（+） 来合并多个字符串。应该使用 StringBuilder 的 append 方法。

## 64. 通过接口引用方法

## 65. 接口优先于反射机制

## 66. 谨慎的使用本地方法

## 67. 谨慎的进行优化

## 68. 遵守不变接受的命名规范

# 异常

## 69. 只针对异常的情况才使用异常

## 70. 对可恢复的情况使用 受检查异常，对编程错误使用 运行 时异常

## 71. 避免不必要的使用受检查异常
## 72. 优先使用标准异常

## 73. 抛出 与抽象对应的异常

## 74. 每个方法 抛出的异常 都要建立文档

## 75. 在 细节消息中 包含失败- 捕获 信息

## 76. 努力使失败保持原子性

任何异常都应该 让对象保持在该方法调用之前的状态。

## 77. 不要忽略异常

# 并发

## 78. 同步访问 共享的 可变 数据

##  79. 避免过度同步

尽量将同步区域内部的工作量限制到最小

## 80. executor、 task 和 stream 优先于线程

## 81. 并发工具优先于 wait 和 notify

## 82. 线程安全性的文档化

## 83. 慎用延时初始化

## 84. 不要依赖于线程调度器

# 序列化

## 85. 其他方法优于序列化

## 86. 谨慎的实现 serializable

## 87. 考虑使用自定义的序列化形式

## 88. 保护性的编写 readObject 方法

## 89. 对于实例的控制，枚举类型优先 于 readResolve

## 90. 考虑使用 序列化代理代替序列化实例