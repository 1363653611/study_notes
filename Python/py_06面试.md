### Python内建数据类型有哪些？

整型--int 布尔型--bool

字符串--str 列表--list

元组--tuple 字典--dict

### Python2和Python3的range(100)的区别是什么？

python2返回列表,python3返回迭代器,节约内存.

### 简述面向对象 `__new__`和 `__init__`的区别？

__init__是初始化方法,创建对象后,就立刻被默认调用了,可接收参数

1、__new__至少要有一个参数cls,代表当前类,此参数在实例化时由Python解释器自动识别

2、__new__必须要有返回值,返回实例化出来的实例,这点在自己实现__new__时要特别注意,可以return父类(通过super(当前类名, cls))__new__出来的实例,或者直接是object的__new__出来的实例

3、__init__有一个参数self,就是这个__new__返回的实例,__init__在__new__的基础上可以完成一些其它初始化的动作,__init__不需要返回值

4、如果__new__创建的是当前类的实例,会自动调用__init__函数,通过return语句里面调用的__new__函数的第一个参数是cls来保证是当前类实例,如果是其他类的类名,;那么实际创建返回的就是其他类的实例,其实就不会调用当前类的__init__函数,也不会调用其他类的__init__函数。

### 请说出python中生成随机整数、随机小数、0--1之间小数的方法？

随机整数:random.randint(a,b),生成区间内的整数

随机小数:习惯用numpy库,利用np.random.randn(5)生成5个随机小数

0-1随机小数:random.random(),括号中不传参

### 避免转义给字符串加哪个字母表示原始字符串?

r , 表示需要原始字符串,不转义特殊字符

python中断言方法举例

assert()方法,断言成功,则程序继续执行,断言失败,则程序报错

### 一句话解释什么样的语言能够用装饰器?

函数可以作为参数传递的语言,可以使用装饰器

### 简要说明with方法打开处理文件帮我们做了什么?

打开文件在进行读写的时候可能会出现一些异常状况,如果按照常规的f.open

写法,我们需要try,except,finally,做异常判断,并且文件最终不管遇到什么情况,都要执行finally f.close()关闭文件,with方法帮我们实现了finally中f.close

### Python中pass语句的作用是什么？

pass语句什么也不做，一般作为占位符或者创建占位程序，pass语句不会执行任何操作，比如：

### Python 有哪些特点和优点？

作为一门编程入门语言，Python 主要有以下特点和优点：

可解释

具有动态特性

面向对象

简明简单

开源

具有强大的社区支持

当然，实际上 Python 的优点远不止如此。

### 深拷贝和浅拷贝之间的区别是什么？

答：深拷贝就是将一个对象拷贝到另一个对象中，这意味着如果你对一个对象的拷贝做出改变时，不会影响原对象。在Python中，我们使用函数deepcopy()执行深拷贝，导入模块copy，如下所示：

```shell
>>> import copy

>>> b=copy.deepcopy(a)
```

![微信图片_20190223111939.jpg](D:\ZBCN\study_notes\Python\py_06面试\1550891965591031.jpg)



而浅拷贝则是将一个对象的引用拷贝到另一个对象上，所以如果我们在拷贝中改动，会影响到原对象。我们使用函数function()执行浅拷贝，使用如下所示：

```shell
>>> b=copy.copy(a)
```

![微信图片_20190223112030.jpg](D:\ZBCN\study_notes\Python\py_06面试\1550892027191666.jpg)



### 列表和元组之间的区别是？

二者的主要区别是列表是可变的，而元组是不可变的。举个例子，如下所示：

```python
>>> mylist=[1,3,3]
>>> mylist[1]=2
>>> mytuple=(1,3,3)
>>> mytuple[1]=2
Traceback (most recent call last):
File "", line 1, in
mytuple[1]=2
```

会出现以下报错： `TypeError: ‘tuple’ object does not support item assignment`

### 解释一下 Python 中的三元运算子

不像 C++，我们在 Python 中没有?:，但我们有这个：

```python
[on true] if [expression] else [on false]
```

如果表达式为True，就执行[on true]中的语句。否则，就执行[on false]中的语句。

下面是使用它的方法：

```python
>>> a,b=2,3
>>> min=a if a
>>> min
```

运行结果：

```python
>>> print("Hi") if a>>> print("Hi") if a
```

### 在 Python 中如何实现多线程？

一个线程就是一个轻量级进程，多线程能让我们一次执行多个线程。我们都知道，Python 是多线程语言，其内置有多线程工具包。

Python 中的 GIL（全局解释器锁）确保一次执行单个线程。一个线程保存 GIL 并在将其传递给下个线程之前执行一些操作，这会让我们产生并行运行的错觉。但实际上，只是线程在 CPU 上轮流运行。当然，所有的传递会增加程序执行的内存压力。

### 解释一下 Python 中的继承

当一个类继承自另一个类，它就被称为一个子类/派生类，继承自父类/基类/超类。它会继承/获取所有类成员（属性和方法）。

继承能让我们重新使用代码，也能更容易的创建和维护应用。Python 支持如下种类的继承：

单继承：一个类继承自单个基类

多继承：一个类继承自多个基类

多级继承：一个类继承自单个基类，后者则继承自另一个基类

分层继承：多个类继承自单个基类

混合继承：两种或多种类型继承的混合

### 什么是 Flask？

Flask 是 Python 编写的一款轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2。Flask 使用 BSD 授权。其中两个环境依赖是 Werkzeug 和 jinja2，这意味着它不需要依赖外部库。正因如此，我们将其称为轻量级框架。

Flask 会话使用签名 cookie 让用户查看和修改会话内容。它会记录从一个请求到另一个请求的信息。不过，要想修改会话，用户必须有密钥 Flask.secret_key。

### 在 Python 中是如何管理内存的？

Python 有一个私有堆空间来保存所有的对象和数据结构。作为开发者，我们无法访问它，是解释器在管理它。但是有了核心 API 后，我们可以访问一些工具。Python 内存管理器控制内存分配。

另外，内置垃圾回收器会回收使用所有的未使用内存，所以使其适用于堆空间。

### 解释 Python 中的 help() 和 dir() 函数

Help() 函数是一个内置函数，用于查看函数或模块用途的详细说明：

```python
>>> import copy
>>> help(copy.copy)
```

运行结果为：

````
Help on function copy in module copy:
copy(x)
Shallow copy operation on arbitrary Python objects.
See the module’s __doc__ string for more info.
````

Dir() 函数也是 Python 内置函数，dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。

以下实例展示了 dir 的使用方法：

```python
>>> dir(copy.copy)
```

运行结果：

```shell
[‘__annotations__’, ‘__call__’, ‘__class__’, ‘__closure__’, ‘__code__’, ‘__defaults__’, ‘__delattr__’, ‘__dict__’, ‘__dir__’, ‘__doc__’, ‘__eq__’, ‘__format__’, ‘__ge__’, ‘__get__’, ‘__getattribute__’, ‘__globals__’, ‘__gt__’, ‘__hash__’, ‘__init__’, ‘__init_subclass__’, ‘__kwdefaults__’, ‘__le__’, ‘__lt__’, ‘__module__’, ‘__name__’, ‘__ne__’, ‘__new__’, ‘__qualname__’, ‘__reduce__’, ‘__reduce_ex__’, ‘__repr__’, ‘__setattr__’, ‘__sizeof__’, ‘__str__’, ‘__subclasshook__’]
```

### 当退出 Python 时，是否释放全部内存？

答案是 No。循环引用其它对象或引用自全局命名空间的对象的模块，在 Python 退出时并非完全释放。

另外，也不会释放 C 库保留的内存部分。

### 什么是猴子补丁？

在运行期间动态修改一个类或模块。

```python
>>> class A:
    def func(self):
        print("Hi")
>>> def monkey(self):
print "Hi, monkey"
>>> m.A.func = monkey
>>> a = m.A()
>>> a.func()
```

输出结果： `Hi, Monkey`

### Python 中的字典是什么？

字典是 C++ 和 Java 等编程语言中所没有的东西，它具有键值对。

```python
>>> roots={25:5,16:4,9:3,4:2,1:1}
>>> type(roots)
>>> roots[9]
```

运行结果为： 3

字典是不可变的，我们也能用一个推导式来创建它。

```python
>>> roots={x**2:x for x in range(5,0,-1)}
>>> roots
```

运行结果：

```shell
{25: 5, 16: 4, 9: 3, 4: 2, 1: 1}
```

### 请解释使用 *args 和 **kwargs 的含义

当我们不知道向函数传递多少参数时，比如我们向传递一个列表或元组，我们就使用*args。

```python
>>> def func(*args):
    for i in args:
        print(i) 
>>> func(3,2,1,4,7)
```

运行结果为：

```shell
3
2
1
4
7
```

在我们不知道该传递多少关键字参数时，使用**kwargs来收集关键字参数。

```python
>>> def func(**kwargs):
    for i in kwargs:
        print(i,kwargs[i])
>>> func(a=1,b=2,c=7)
```

运行结果为

```shell
a.1
b.2
c.7
```

### Python中的闭包是什么？

当一个嵌套函数在其外部区域引用了一个值时，该嵌套函数就是一个闭包。其意义就是会记录这个值。

```python
>>> def A(x):
    def B():
        print(x)
    return B
>>> A(7)()
```

### 怎么移除一个字符串中的前导空格？

```python
'   Ayushi '.lstrip() # 移除前导空格
'   Ayushi '.rstrip()  # 移除后导空格
```

### 如何以就地操作方式打乱一个列表的元素？

为了达到这个目的，我们从random模块中导入shuffle()函数。

```python
>>> from random import shuffle
>>> shuffle(mylist)
>>> mylist
```

### 什么是负索引？

负索引和正索引不同，它是从右边开始检索。 `mylist[-3]`

### 什么是切片

`mylist[-6:-1]`



### python字符串格式化中，%s和.format的主要区别是什么

python用一个tuple将多个值传递给模板，每个值对应一个格式符
print（“ my name is %s ,im %d year old”%("gaoxu",19))
自从python2.6开始，新增了一种格式化字符串的函数str.format(），通过{}和.来代替传统的%
主要的区别是：不需要指定的字符串还是数字类型

```python
print('ma name is {} ,age is {} year old'.format("小明",17))
print('my name is {1},age is {0}'.format(15,'小明'))
#:位置攒参的方式li=['hollo',18]print('may name is {0},my year old is {1}'.format(*li))
# 按照关键字传参hash={'name':'hoho','age':18}print ('my name is {name},age is {age}'.format(**hash))
```

### 现有两个元组，（('a'),('b')）,（('c'),('d')）请用匿名函数把他变成{{'a':'c'},{'b':'d'}}

```python
t1=（('a'),('b')）
t2=（('c'),('d')）
res=lambda:t1,t2;[i:j}for i,j in zip(t1,t2)]
print(res(t1,t2))
```

### 如何给列表去重并保持原来的顺序不变

```python
l=[11,2,3,4,7,6,4,3,54,3,]
now_l=[]for i in l:if i not in now_l:
now_l.append(i)print(now_l)
也可以用set直接去重和排序print(set(l)
```

### 解释什么是匿名函数，它有什么好处

匿名函数与函数有共同的作用域，但是匿名函数意味着引用计数为0除非让他有名字
好处：一次性使用，随时随地的定义更容易阅读，做了什么更是一目了然

### python如何书写可变参数和关键字参数

在python中定义函数，可也用必选函数，默认参数，可变参数，和关键字参数，这四种参数都可以一块使用，或者只用其中的一些但是请注意的是参数定义的顺序必须是必选参数，默认参数，可变参数，关键字参数

### python模块中match和search的区别
re.match（）总是匹配的是字符串的开头，并返回匹配的math对象，如果去匹配字符串非开头的部分就会返回none
re.search（）函数对整个字符串进行搜索，并返回第一个匹配字符串的match对象

### 1 and 2和1 or2输出结果是什么
python中的and是从左往右计算的，若所有的值都是真的，则返回最后一个，若存在假的，返第一个假的，1 or 2因为是1是非零,所以返回的值是1

### 示例说明args和**kwargs
*args(表示的就是将实参中按照位置传参，多余的都是给args，切都是以元组的方式实现）
**kwargs:(表示的是按照关键字传参，保存的是字典的形式

### python2和python3的区别

python3的字节是python2的字符串
python3的字符窜是python2的unciode
在python3中print要加括号
在python3中数字除法有小数点

### 迭代器，生成器,装饰器

迭代器即迭代工具，那么什么是迭代那
迭代重复上一个重复的过程，每一次重复即一次迭代，并且每一次迭代的结果都是下一次迭代的开始
为何要用迭代器
对于序列类型：字符串，列表，元组，我们可以使用索引的方式迭代取出包含的元素
对于字典，集合，文件等类型没有索引，若还行取出内部包的元素，则需要找出不依赖索引的方式，那这就是迭代器
什么是可迭代的对象，具有init方法返回就是迭代器，具有next方法
特点优点：提供了一种不依赖索引的取值的方式
缺点： 只能往前循环，不能往后找无法获取长度，
注意的是：迭代器对象一定是可迭代对象，但可迭代对象不一定是迭代器的对象
生成器迭代器的一种关键字yield+关键字，next方法，yield语句一次返回一个结果，在每个
结果中间挂起钩子函数，以便下次重它离开的地方继续
生成器表达式类似于列表推导式，但是生成器返回按需求产生结果的一个对象，而不是一次构建
一个结果的列表
特点：惰性运算，节省空间
装饰器：在不改变原来函数和函数的调用方式进行扩展，就是对外开放，对内封闭的原则
目标：为被装饰的对象添加新的功能

### 谈谈你对python装饰器的理解

装饰器本质上就是一个python函数,它可以让其他函数在不需要任何代码变动的前提下增加额外的功能
，装饰器的返回值也是一个函数对象，她有很多的应用场景，比如：插入日志，事物处理，缓存，权限装饰器就是为已经存在的对象
添加额外功能

```python
def outher(func):
       def good(*args,**kwargs):
               ret=func(*args,**kwargs)                
                return ret       
         return good@outherdef bar():
      print('狗241131313')
bar()
```

### 简述python中垃圾回收机制

主要是以对象引用计数为主标记清除和分带技术为辅的那么一种方式
Python在内存中存储了每个对象的引用计数（reference count）。如果计数值变为0，那么相应的对象就会消失。分配给该对象的内存就会释放出来用作他用。
偶尔也会出现引用循环。垃圾回收器会定时寻找这个循环，并将其回收。
Python中还使用了某些启示算法来加速回收。

### 请解释Python中的statimethod(静态方法）和classmethod（类方法）,



### 请解释生成器和函数的不同，并实现简单的生成器与函数
```python
# def beautiful(c):
# for i in range(c):
# yield i**2
# for item in beautiful(5):
# print(item)#函数
# def gensquares(N):
# res=[0]
# for i in range(N):
# res.append(i*i)
# return res# for item in gensquares(5):
# print(item)
```



总结：
1语法上和函数类似：生成器函数和常规函数几乎一模一样的,他们都是使用def语句进行
定义，区别在于，生成器使用yield语句返回一个值，而常规函数使用return语句返回一个值
2.自动实现迭代器的协议：对于生成器，python自动实现迭代器协议，所以我们可以调用它的next
方法，并且在没有值返回的时候，生成器自动生成Stopltwration异常
3.状态挂起，生成器使用yield语句返回一个值.yield语句挂起该生成器函数的状态，保留足够的信息，方便之后离开的
地方继续执行



### Django的请求生命周期
1，当用户在浏览器中输入url时浏览器会生成请求头和请求体发送给服务端请求头和请求体中会包含浏览器的动作（action）这个动作通常为get或者post提现在url之中
2.url经过Django中的wsgi再经过django的中间件，最后url到路由的映射表一条一条进行匹配一旦其中的某一条匹配成功就执行视图函数，后面的路由就不在继续匹配了
3视图函数根据客户端的请求查询相应的数据，返回给Django，然后Django把客户端想要的数据作为一个字符串返回给客户端
4客户端浏览器接受到返回的数据，经过渲染后显示给用

### django rest framework规范

1url后尽量用名词，因为rest frame是面向资源的编程，因此url命名时能体现出资源
2method的不同，实现增删改查的操作
3版本号，因为有版本的更替，为了体现出版本的过度，因此在发请求的时候，要体现出版本号
4返回值，与以往只返回json不同,rest api规范要加上状态码。
5域名，由于前后端分离，因此要处理跨域问题，解决方法:jsonp,cors
6过滤，通过url传参的形式传递搜索条件（列如：指定返回的记录数量，指定分页等）

### jsonp和cors
jsonp的本质就是利用script的src属性绕过同源策略
cors
整个cors通信过程，都是浏览器自动完成，不需要用户参与，对于开发者来说cors通信和同源的ajax没有什么区别，挨代码完全一样，浏览器一旦发现ajax请求跨源，就会自动添加一些附加头的信息，有时还会多出一次附加的请求，但用户不会有感觉.