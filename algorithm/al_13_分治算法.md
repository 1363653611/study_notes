## 分治算法（divide and conquer）: 分而治之

将原问题分为 n 个规模更小并且结果与原问题相似的子问题，递归的解决这些子问题，然后合并其结果，得到愿问题的解。

**分治** 是一种解决问题的思想，而 **递归** 是编程技巧。 分治算法 适合用 递归来实现：

### 技巧：

1. 分解：将原问题分解成一系列子问题
2. 解决：递归的求解各个子问题，若子问题足够小，则直接求解
3. 合并：将子问题的结果合并成原问题的结果

### 适合用分治算法解决的问题的特点

1. 原问题与分解成的子问题有相同的结构
2. 原问题分解成的子问题可以独立求解。子问题之间没有关联性，这一点 分治算法和 动态规划之间有明确的区别
3. 具备分解终止条件，也就是说，当问题足够小时，可以求解。
4. 可以将子问题的结果合并成原问题的结果，而且合并代价不能太大，否则就不能达到降低时间复杂度的良好效果

## 实例

如何用编程的方法求解出一组数据的有序对个数或者逆序对个数

### 笨方法

用每个数字与他后面的数字比较，查看有几个数字比它小，我们把位于其后，又比其小的数字的个数计作k 值。通过这样的方式，我们将每个数字考察一边后，对每个数字对应的 k 值求和，最后得到的总和就是逆序对的个数。

时间复杂度： O(n2)

### 分而治之

我们将 数组分成 A1 和 A2 两个部分，首先分别计算得到 A1 和 A2 的逆序对个数分别 是 K1 和 K2。然后计算 A1 和 A2之间的逆序对个数  K3(逆序对中的前一个数字来自于A1，后一个数字 来自于A2),那么数组 A 的逆序对个数为 K1+K2 + K3.

```java
/**
 * 求给定数组的逆序度
 * 如何用编程的方法求解出一组数据的有序对个数或者逆序对个数
 */
public class T23_nixudu {

    /**
     * 全局变量-逆序度
     */
    private int num = 0;
    
    
    private int count(int[] a,int n){
        num = 0;
        mergeSortCount(a,0,n-1);
        return num;
    }
    
    private void mergeSortCount(int[] a, int p, int r){
        if (p >= r){
            return;
        }
        int q = (r + p)/2;
        mergeSortCount(a,p,q);
        mergeSortCount(a, q +1,r);
        merge(a,p,q,r);
    }

    //在每次合并操作过程中，我们顺便计算两个小数组之间的逆序对个数，把这些计算出来的逆序对个数求和，
    //就是整个逆序对个数
    public void merge(int[] a, int p,int q,int r){

        int i = p, j = q+1, k = 0;

        // 临时数组，存储排好序的数据
        int[] temp = new int[r-p + 1];

        while (r <=q && j <=r){
            if (a[i] < a[j]){
                //顺序
                temp[k++] = a[i++];
            }else {
                // 统计 p -q 之间，比 a[j] 元素大的个数
                num = (q-i +1);
                temp[k++] = a[j++];
            }
        }

        //处理剩下的
        while (i <=q){
            temp[k++] = a[i++];
        }
        //处理剩下的
        while (j <=r){
            temp[k++] = a[j++];
        }
        // 从temp 复制回 a
        for ( i = 0; i <r-p; ++i){
            a[p+i] = temp[i];
        }
    }
}
```

